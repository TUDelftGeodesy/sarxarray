{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SARXarray","text":"<p>SARXarray is an open-source Xarray extension for Synthetic Aperture Radar (SAR) data.</p> <p>SARXarray is especially designed to work with complex data, that is, containing both the phase and amplitude of the data. The extension can handle coregistered stacks of Single Look Complex (SLC) data, as well as derived products such as interferogram stacks. It utilizes Xarray\u2019s support on labeled multi-dimensional datasets to stress the space-time character of the image stacks. Dask Array is implemented to support parallel computation.</p> <p>SARXarry supports the following functionalities:</p> <ol> <li> <p>Chunk-wise reading/writing of coregistered SLC or interferogram stacks;</p> </li> <li> <p>Basic operations on complex data, e.g., averaging along axis and complex conjugate multiplication;</p> </li> <li> <p>Specific SAR data operations, e.g., multilooking and coherence estimation.</p> </li> </ol> <p>All the above functionalities can be scaled up to a Hyper-Performance Computation (HPC) system.</p>"},{"location":"common_ops/","title":"Common SLC operations","text":"<p>Common SAR processings can be performed by SARXarray. Below are some examples:</p>"},{"location":"common_ops/#multi-look","title":"Multi-look","text":"<p>Multi-look by a windowsize, e.g. 2 in azimuth dimension and 4 in range dimension:</p> <pre><code>stack_multilook = stack.slcstack.multi_look((2,4))\n</code></pre>"},{"location":"common_ops/#coherence","title":"Coherence","text":"<p>Compute coherence between two SLCs:</p> <pre><code>slc1 = stack.isel(time=[0]) # first image\nslc2 = stack.isel(time=[2]) # third image\nwindow = (4,4)\n\ncoherence = slc1.slcstack.complex_coherence(slc2, window)\n</code></pre>"},{"location":"common_ops/#mean-reflection-map-mrm","title":"Mean-Reflection-Map (MRM)","text":"<pre><code>mrm = stack_multilook.slcstack.mrm()\n</code></pre> <pre><code>from matplotlib import pyplot as plt\nfig, ax = plt.subplots()\nax.imshow(mrm)\nmrm.plot(ax=ax, robust=True, cmap='gray')\n</code></pre>"},{"location":"common_ops/#point-selection","title":"Point selection","text":"<p>A selection based on temporal properties per pixel can be performed. For example, we can select the Persistent Scatters (PS) by temporal dispersion of <code>amplitude</code>:</p> <pre><code>ps = stack.slcstack.point_selection(threshold=0.25, method=\"amplitude_dispersion\")\n</code></pre>"},{"location":"data_loading/","title":"Usage","text":""},{"location":"data_loading/#input-data-format","title":"Input data format","text":"<p>SARXarry works with corregitserred SLC / interferogram stack. Conventionally they are provided in binary format. SARXarry provides a reader to perform lazy loading on a binary stack. However, we recommend to store the corregitserred stack in <code>zarr</code> format, and directly load them as an Xarray object by <code>xarray.open_zarr</code>. </p>"},{"location":"data_loading/#loading-corregisterred-slc-stack-in-binary-format","title":"Loading corregisterred SLC stack in binary format","text":"<p>If the stack is saved in binary fomat, it can be read by <code>SARXarray</code> under two prerequisites:</p> <ol> <li>All SLCs/interferograms have the same known raster size and data type;</li> <li>All SLCs/interferograms have been resampled to the same raster grid.</li> </ol> <p>For example, let's consider a case of an stack with three SLCs:</p> <pre><code>import numpy as np\nlist_slcs = ['data/slc_1.raw', 'data/slc_2.raw', 'data/slc_3.raw']\nshape = (10018, 68656) # (azimuth, range)\ndtype = np.complex64\n</code></pre> <p>We built a list <code>list_slcs</code> with the paths to the SLCs. In this case they are stored in the same directory called <code>data</code>. The shape of each SLC is known: <code>10018</code> pixels in <code>azimuth</code> direction, and <code>68656</code> in range direction. The data type is <code>numpy.complex64</code>.</p> <p>The corregisterred SLC stack can be read using <code>from_binary</code> function:</p> <pre><code>import sarxarray\n\nstack = sarxarray.from_binary(list_slcs, shape, dtype=dtype)\n</code></pre> <p>You can also skip the <code>dtype</code> argument since it's defaulted to <code>np.complex64</code>. The stack will be read as an <code>xarray.Dataset</code> object, with data variables lazily loaded as <code>Dask Array</code>:</p> <pre><code>print(stack)\n\n&lt;xarray.Dataset&gt;\nDimensions:    (azimuth: 10018, range: 68656, time: 3)\nCoordinates:\n  * azimuth    (azimuth) int64 0 1 2 3 4 5 ... 10013 10014 10015 10016 10017\n  * range      (range) int64 0 1 2 3 4 5 ... 68650 68651 68652 68653 68654 68655\n  * time       (time) int64 0 1 2\nData variables:\n    complex    (azimuth, range, time) complex64 dask.array&lt;chunksize=(4000, 4000, 1), meta=np.ndarray&gt;\n    amplitude  (azimuth, range, time) float32 dask.array&lt;chunksize=(4000, 4000, 1), meta=np.ndarray&gt;\n    phase      (azimuth, range, time) float32 dask.array&lt;chunksize=(4000, 4000, 1), meta=np.ndarray&gt;\n</code></pre> <p>The loading chunk size can also be specified manually:</p> <pre><code>stack_smallchunk = sarxarray.from_binary(list_slcs, shape, chunks=(2000, 2000))\n</code></pre>"},{"location":"manipulations/","title":"Manipulate an SLC stack as an Xarray","text":"<p>The loaded stack can be manipulated as an <code>Xarray.Dataset</code> instance.</p> <p>Slice the SLC stack in 3D:</p> <pre><code>stack.isel(azimuth=range(1000,2000), range=range(1500,2500), time=range(2,5))\n</code></pre> <p>Select <code>amplitude</code> attributes</p> <pre><code>amp = stack['amplitude']\n</code></pre> <p>Compute stack and peresist in memory:</p> <pre><code>stack = stack.compute()\n</code></pre>"},{"location":"setup/","title":"Installation","text":"<p>SARXarray can be installed from PyPI:</p> <pre><code>pip install sarxarray\n</code></pre> <p>or from the source:</p> <pre><code>git clone git@github.com:MotionbyLearning/sarxarray.git\ncd sarxarray\npip install .\n</code></pre> <p>Note that Python version <code>&gt;3.10</code> is required for SARXarray.</p>"},{"location":"setup/#tips","title":"Tips","text":"<p>We strongly recommend installing separately from your default Python envrionment. E.g. you can use enviroment manager e.g. conda to create separate environment.</p>"},{"location":"notebooks/demo_sarxarray/","title":"Example Notebook","text":"<p>You can download this Jupyter Notebook via the download button at the top of this page.</p> <p>In this Jupyter Notebook, we demonstrate the following operations using <code>sarxarray</code>:</p> <ul> <li>Load an SLC stack in binary format into a <code>xarray.Dataset</code> object;</li> <li>Append lat and lon coordinates to the loaded stack;</li> <li>Create an MRM of a subset of the SLC stack;</li> <li>Apply common SAR processings to the SLC stack;</li> <li>Export the selection results in Zarr format</li> </ul> In\u00a0[1]: Copied! <pre>import numpy as np\nfrom pathlib import Path\nimport sarxarray\n</pre> import numpy as np from pathlib import Path import sarxarray <p>We will load the interferogram stack, which has been corregistered and saved as binary files. We assume the shape and data type is known.</p> In\u00a0[2]: Copied! <pre># Path to the interferogram dataset\npath = Path('../../../data/nl_amsterdam_s1_asc_t088')\n\n# Make a list of SLCs to read\nf_slc = 'cint_srd.raw'\nlist_slcs = [p for p in path.rglob('*_cint_srd.raw')]\nlist_slcs.sort()\n\n# Metadata of the stack, assume known.\nshape=(2000, 4000)\n\n# Define reading chunks\nreading_chunks = (500,500)\n</pre> # Path to the interferogram dataset path = Path('../../../data/nl_amsterdam_s1_asc_t088')  # Make a list of SLCs to read f_slc = 'cint_srd.raw' list_slcs = [p for p in path.rglob('*_cint_srd.raw')] list_slcs.sort()  # Metadata of the stack, assume known. shape=(2000, 4000)  # Define reading chunks reading_chunks = (500,500) In\u00a0[3]: Copied! <pre># Check the list of SLCs\nprint(list_slcs)\n</pre> # Check the list of SLCs print(list_slcs) <pre>[PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20180920_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20180926_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181002_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181008_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181014_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181020_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181026_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181101_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181107_cint_srd.raw'), PosixPath('../../../data/nl_amsterdam_s1_asc_t088/20181113_cint_srd.raw')]\n</pre> <p>Use <code>from_binary</code> to load the stack:</p> In\u00a0[4]: Copied! <pre># Load complex data\nstack = sarxarray.from_binary(list_slcs, shape, dtype=np.complex64, chunks=reading_chunks)\n\nprint(stack)\n</pre> # Load complex data stack = sarxarray.from_binary(list_slcs, shape, dtype=np.complex64, chunks=reading_chunks)  print(stack) <pre>&lt;xarray.Dataset&gt;\nDimensions:    (azimuth: 2000, range: 4000, time: 10)\nCoordinates:\n  * azimuth    (azimuth) int64 0 1 2 3 4 5 6 ... 1994 1995 1996 1997 1998 1999\n  * range      (range) int64 0 1 2 3 4 5 6 ... 3994 3995 3996 3997 3998 3999\n  * time       (time) int64 0 1 2 3 4 5 6 7 8 9\nData variables:\n    complex    (azimuth, range, time) complex64 dask.array&lt;chunksize=(500, 500, 1), meta=np.ndarray&gt;\n    amplitude  (azimuth, range, time) float32 dask.array&lt;chunksize=(500, 500, 1), meta=np.ndarray&gt;\n    phase      (azimuth, range, time) float32 dask.array&lt;chunksize=(500, 500, 1), meta=np.ndarray&gt;\n</pre> In\u00a0[5]: Copied! <pre># Geo-referenced coordinates\nf_lat = [path / 'lat.raw']\nf_lon = [path / 'lon.raw']\n</pre> # Geo-referenced coordinates f_lat = [path / 'lat.raw'] f_lon = [path / 'lon.raw'] In\u00a0[6]: Copied! <pre># Load coordinates\nlat = sarxarray.from_binary(\n    f_lat, shape, vlabel=\"lat\", dtype=np.float32, chunks=reading_chunks\n)\nlon = sarxarray.from_binary(\n    f_lon, shape, vlabel=\"lon\", dtype=np.float32, chunks=reading_chunks\n)\nstack = stack.assign_coords(\n    lat=((\"azimuth\", \"range\"), lat.squeeze().lat.data),\n    lon=((\"azimuth\", \"range\"), lon.squeeze().lon.data),\n)\n</pre> # Load coordinates lat = sarxarray.from_binary(     f_lat, shape, vlabel=\"lat\", dtype=np.float32, chunks=reading_chunks ) lon = sarxarray.from_binary(     f_lon, shape, vlabel=\"lon\", dtype=np.float32, chunks=reading_chunks ) stack = stack.assign_coords(     lat=((\"azimuth\", \"range\"), lat.squeeze().lat.data),     lon=((\"azimuth\", \"range\"), lon.squeeze().lon.data), ) In\u00a0[7]: Copied! <pre>print(stack)\n</pre> print(stack) <pre>&lt;xarray.Dataset&gt;\nDimensions:    (azimuth: 2000, range: 4000, time: 10)\nCoordinates:\n  * azimuth    (azimuth) int64 0 1 2 3 4 5 6 ... 1994 1995 1996 1997 1998 1999\n  * range      (range) int64 0 1 2 3 4 5 6 ... 3994 3995 3996 3997 3998 3999\n  * time       (time) int64 0 1 2 3 4 5 6 7 8 9\n    lat        (azimuth, range) float32 dask.array&lt;chunksize=(500, 500), meta=np.ndarray&gt;\n    lon        (azimuth, range) float32 dask.array&lt;chunksize=(500, 500), meta=np.ndarray&gt;\nData variables:\n    complex    (azimuth, range, time) complex64 dask.array&lt;chunksize=(500, 500, 1), meta=np.ndarray&gt;\n    amplitude  (azimuth, range, time) float32 dask.array&lt;chunksize=(500, 500, 1), meta=np.ndarray&gt;\n    phase      (azimuth, range, time) float32 dask.array&lt;chunksize=(500, 500, 1), meta=np.ndarray&gt;\n</pre> <p>Some common SAR operations are supported by SARXarray</p> In\u00a0[8]: Copied! <pre>stack_multilook = stack.slcstack.multi_look((1,2))\nprint(stack_multilook)\n</pre> stack_multilook = stack.slcstack.multi_look((1,2)) print(stack_multilook) <pre>&lt;xarray.Dataset&gt;\nDimensions:    (azimuth: 2000, range: 2000, time: 10)\nCoordinates:\n  * azimuth    (azimuth) int64 0 1 2 3 4 5 6 ... 1994 1995 1996 1997 1998 1999\n  * range      (range) int64 0 1 2 3 4 5 6 ... 1994 1995 1996 1997 1998 1999\n  * time       (time) int64 0 1 2 3 4 5 6 7 8 9\n    lat        (azimuth, range) float32 dask.array&lt;chunksize=(500, 250), meta=np.ndarray&gt;\n    lon        (azimuth, range) float32 dask.array&lt;chunksize=(500, 250), meta=np.ndarray&gt;\nData variables:\n    complex    (azimuth, range, time) complex64 dask.array&lt;chunksize=(500, 250, 10), meta=np.ndarray&gt;\n    amplitude  (azimuth, range, time) float32 dask.array&lt;chunksize=(500, 250, 10), meta=np.ndarray&gt;\n    phase      (azimuth, range, time) float32 dask.array&lt;chunksize=(500, 250, 10), meta=np.ndarray&gt;\nAttributes:\n    multi-look:  coarsen-mean\n</pre> In\u00a0[9]: Copied! <pre>mrm = stack_multilook.slcstack.mrm()\nprint(mrm)\n</pre> mrm = stack_multilook.slcstack.mrm() print(mrm) <pre>&lt;xarray.DataArray 'amplitude' (azimuth: 2000, range: 2000)&gt;\ndask.array&lt;mean_agg-aggregate, shape=(2000, 2000), dtype=float32, chunksize=(500, 250), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * azimuth  (azimuth) int64 0 1 2 3 4 5 6 ... 1994 1995 1996 1997 1998 1999\n  * range    (range) int64 0 1 2 3 4 5 6 ... 1993 1994 1995 1996 1997 1998 1999\n    lat      (azimuth, range) float32 dask.array&lt;chunksize=(500, 250), meta=np.ndarray&gt;\n    lon      (azimuth, range) float32 dask.array&lt;chunksize=(500, 250), meta=np.ndarray&gt;\n</pre> In\u00a0[10]: Copied! <pre># Visualize\nfrom matplotlib import pyplot as plt\nfig, ax = plt.subplots()\nfig.set_size_inches((5,5))\nax.imshow(mrm)\nim = mrm.plot(ax=ax, robust=True, cmap='gray')\nim.set_clim([0, 50000])\n</pre> # Visualize from matplotlib import pyplot as plt fig, ax = plt.subplots() fig.set_size_inches((5,5)) ax.imshow(mrm) im = mrm.plot(ax=ax, robust=True, cmap='gray') im.set_clim([0, 50000]) In\u00a0[11]: Copied! <pre># Select a subset\nstack_subset = stack.sel(azimuth=range(100,1800), range=range(1000,3000))\n\n# Perform point selection\nstm = stack_subset.slcstack.point_selection(threshold=0.20, method=\"amplitude_dispersion\")\n\nprint(stm)\n</pre> # Select a subset stack_subset = stack.sel(azimuth=range(100,1800), range=range(1000,3000))  # Perform point selection stm = stack_subset.slcstack.point_selection(threshold=0.20, method=\"amplitude_dispersion\")  print(stm) <pre>&lt;xarray.Dataset&gt;\nDimensions:    (time: 10, space: 78582)\nCoordinates:\n  * time       (time) int64 0 1 2 3 4 5 6 7 8 9\n    lat        (space) float32 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\n    lon        (space) float32 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\n    azimuth    (space) int64 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\n    range      (space) int64 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\nDimensions without coordinates: space\nData variables:\n    complex    (space, time) complex64 dask.array&lt;chunksize=(1000, 10), meta=np.ndarray&gt;\n    amplitude  (space, time) float32 dask.array&lt;chunksize=(1000, 10), meta=np.ndarray&gt;\n    phase      (space, time) float32 dask.array&lt;chunksize=(1000, 10), meta=np.ndarray&gt;\nAttributes:\n    multi-look:  coarsen-mean\n</pre> In\u00a0[12]: Copied! <pre>from matplotlib import pyplot as plt\nfig, ax = plt.subplots()\nplt.scatter(stm.lon.data, stm.lat.data, s=0.1)\n</pre> from matplotlib import pyplot as plt fig, ax = plt.subplots() plt.scatter(stm.lon.data, stm.lat.data, s=0.1) Out[12]: <pre>&lt;matplotlib.collections.PathCollection at 0x7f37805a8100&gt;</pre> <p>The selected points can be saved to a <code>Zarr</code> storage.</p> In\u00a0[13]: Copied! <pre># Export to Zarr\nstm.to_zarr(\"stm.zarr\", mode=\"w\")\n</pre> # Export to Zarr stm.to_zarr(\"stm.zarr\", mode=\"w\") Out[13]: <pre>&lt;xarray.backends.zarr.ZarrStore at 0x7f37781ed8c0&gt;</pre> <p>And can be read by <code>xr.open_zarr</code></p> In\u00a0[14]: Copied! <pre># Load exported STM in Zarr\nimport xarray as xr\nstm_read = xr.open_zarr(\"stm.zarr\")\nprint(stm_read)\n</pre> # Load exported STM in Zarr import xarray as xr stm_read = xr.open_zarr(\"stm.zarr\") print(stm_read) <pre>&lt;xarray.Dataset&gt;\nDimensions:    (space: 78582, time: 10)\nCoordinates:\n    azimuth    (space) int64 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\n    lat        (space) float32 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\n    lon        (space) float32 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\n    range      (space) int64 dask.array&lt;chunksize=(1000,), meta=np.ndarray&gt;\n  * time       (time) int64 0 1 2 3 4 5 6 7 8 9\nDimensions without coordinates: space\nData variables:\n    amplitude  (space, time) float32 dask.array&lt;chunksize=(1000, 10), meta=np.ndarray&gt;\n    complex    (space, time) complex64 dask.array&lt;chunksize=(1000, 10), meta=np.ndarray&gt;\n    phase      (space, time) float32 dask.array&lt;chunksize=(1000, 10), meta=np.ndarray&gt;\nAttributes:\n    multi-look:  coarsen-mean\n</pre>"},{"location":"notebooks/demo_sarxarray/#example-notebook","title":"Example Notebook\u00b6","text":""},{"location":"notebooks/demo_sarxarray/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/demo_sarxarray/#data-preparation","title":"Data preparation\u00b6","text":"<p>We use a corregisterred and georeferenced Sentinel-1 interferogram stack over Amsterdam as an example dataset. Please download the data and unzip it locally.</p>"},{"location":"notebooks/demo_sarxarray/#environment-setup","title":"Environment setup\u00b6","text":"<p>For the python environment setup, we assume you already installed SARXarray following the installation guide.</p> <p>Some extra python dependencies are required to execute this notebook. You can install the extra python dependencies by:</p> <pre>pip install sarxarray[demo]\n</pre> <p>After installation, execute the notebook in a JupyterLab session, which can be started by running <code>jupyterlab</code> command in your command line:</p> <pre>jupyter-lab\n</pre> <p>A new tab will be opened in your default browser to execute this notebook.</p>"},{"location":"notebooks/demo_sarxarray/#data-loading","title":"Data loading\u00b6","text":""},{"location":"notebooks/demo_sarxarray/#append-georeferenced-coordinates","title":"Append georeferenced coordinates\u00b6","text":"<p>The <code>sarxarray</code> is implemented as an extension of <code>Xarray.Dataset</code>, which means we can modify the <code>stack</code> variable as a normal <code>Dataset</code> objet. For example, we can append geo-refrenced coordinates to the loaded stack.</p>"},{"location":"notebooks/demo_sarxarray/#common-sar-operations","title":"Common SAR operations\u00b6","text":""},{"location":"notebooks/demo_sarxarray/#multi-looking","title":"Multi-Looking\u00b6","text":"<p>We apply a <code>(1, 2)</code> multi-look to the loaded stack. As a result the size of the output will be <code>(2000, 2000)</code>.</p>"},{"location":"notebooks/demo_sarxarray/#mean-reflection-map-mrm","title":"Mean Reflection Map (MRM)\u00b6","text":""},{"location":"notebooks/demo_sarxarray/#select-coherent-pixels","title":"Select coherent pixels\u00b6","text":"<p>One can select the coherent pixels by <code>point_selection</code> function. For example select pixels with <code>amplitude_dispersion</code> lower than <code>0.2</code>.</p>"},{"location":"notebooks/demo_sarxarray/#export-results","title":"Export results\u00b6","text":""}]}